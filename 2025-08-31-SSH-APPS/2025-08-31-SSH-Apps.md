# Secure SSH Shell Applications

While modern software often leans heavily on graphical interfaces and web applications, command-line-based applications are still very much alive and in use. In fact, SSH-based shell applications remain a lightweight, efficient way for users to interact with terminal-based programs. However, if not configured carefully, these applications can inadvertently provide users with unrestricted shell access â€” something thatâ€™s often not intended.

The good news? Securing SSH shell applications is straightforward and can be done quickly with a few well-placed configurations. This article walks through how to set up a terminal-based application accessed via SSH and secure it in a way that restricts users to just the application.

---

## Table of Contents

1. [What is an SSH Shell Application?](#what-is-an-ssh-shell-application)
2. [Setting Up the Application](#setting-up-the-application)
3. [Configuring SSH for Application Access](#configuring-ssh-for-application-access)
4. [Console Access Considerations](#console-access-considerations)
5. [Summary](#summary)

---

## What is an SSH Shell Application?

SSH Shell Applications are terminal-based programs that users can run remotely by connecting over SSH. They are especially handy in environments where minimal resource usage is critical or where web interfaces are overkill.

Users can connect using SSH clients like **PuTTY**, **Termius**, or native Linux/macOS terminals. These apps are lightweight, fast, and easy to distribute. Because they donâ€™t rely on the userâ€™s home environment or graphical stack, they can also add an extra layer of separation and security.

However, without careful planning, a user might break out of the application into a standard shell â€” unintentionally or otherwise. Thatâ€™s why additional steps must be taken to confine users strictly to the appâ€™s environment.

---

Setting Up the Application

For our example, we'll use a simple, self-contained Python application placed in /opt/test_app/app_entrypoint.py. A key part of securing this app is disabling critical control characters like Ctrl+C and Ctrl+Z, which would otherwise interrupt the application or suspend it to the background, potentially giving the user shell access.

Hereâ€™s how we disable those signals:

---

## Configuring SSH for Application Access

There are two main ways to launch an SSH shell app:

1. From the user's `.bashrc` or similar login script.
2. Directly from the SSH daemon (`sshd`) configuration.

This article focuses on the second method, which is cleaner and more secure.

First, a dedicated Linux group (e.g., `app_group`) is created to contain the application users. Then, we use SSHD's `Match Group` directive to force members of that group to run only the application.

Here's a sample snippet added to `/etc/ssh/sshd_config`:

```bash
Match Group app_group
    ForceCommand /opt/test_app/app_entrypoint.py
    PermitTTY yes
    AllowTcpForwarding no
    X11Forwarding no
```

This configuration ensures that:

* Users in `app_group` are automatically placed into the application.
* `PermitTTY yes` allows for interactive input.
* `AllowTcpForwarding` and `X11Forwarding` are disabled to prevent the session from being misused as a jump host.

Regular system administrators or non-application users are unaffected and continue to log in normally.

---

## Console Access Considerations

While SSH access is now locked down, donâ€™t forget about direct console access or users logging in via `su - app_user`. In these cases, users can still access the full shell unless additional safeguards are in place.

To block non-SSH logins (such as physical terminal or `su` sessions), add the following to the app userâ€™s `.bashrc`:

```bash
if [ -z "$SSH_CONNECTION" ]; then
  echo "ðŸš« Direct login is not allowed."
  exit 1
fi
```

This script checks whether the session is initiated over SSH. If itâ€™s not, the login is terminated immediately.

---

## Summary

In this guide, weâ€™ve walked through how to:

* Create a simple terminal-based application.
* Restrict user access to that app only via SSH.
* Prevent users from breaking out of the application into the shell.
* Secure against direct console or `su` access.

These steps don't indicate a lack of trust in users. Most end users donâ€™t have the means or intent to break out of restricted environments â€” but we always prepare for the worst. If a threat actor ever gains access to one of these accounts, these protections act as a vital layer of defense.

**Security is all about layers.** Beyond giving users access to the tools or files they need, we must always ask: *Do they need shell access too?* If the answer is no, letâ€™s make sure the system enforces it.
